---
title: "Metropolis-Hastings Algorithm Demo"
output: html_document:
---

## Introduction 

The **Metropolis_Hastings algorithm** is a Markov Chain Monte Carlo method for generating samples from a target distribution when direct sampling is difficult. It constructs a Markov chain that has the target distribution as its stationary distribution.


For this project, we implement a 2-dimensional version of the algorithm, targeting a bivariate distribution. 

\[
f(a, b) \propto \exp(-2a^2 - 2ab - b^2)
\]

Since this isn't a standard distribution we use Markov Chain Monte Carlo to approximate samples from it. 


## Method

Describe the components:
- Target distribution
- Proposal distribution
- Acceptance probability
- Data types used


## R Implementation

```{r}
# Read in required packages
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse)
# Define functions
target <- function(a, b){ exp(-2 * a^2 - 2 * a * b - b^2) }
candidate <- function(a1, b1, a_mean, b_mean, var) {
dnorm(a1, a_mean, sqrt(var)) * dnorm(b1, b_mean, sqrt(var))
}
# Initialize values
set.seed(seed <- 25) # Random number seed
candidate_variance <- 1.5^2 # Marginal variance of candidate distribution
num_reps <- 10^5 # Number of values to simulate
previous_x <- 2 # Initial value
previous_y <- -1
df <- data.frame(draw = 0,
previous_x = previous_x, previous_y = previous_y,
candidate_x = NA, candidate_y = NA, alpha = NA, u = NA, accept = NA,
retained_x = previous_x, retained_y = previous_y)
# Loop to complete as many iterations as desired
for (i in c(1:num_reps)){
draw <- i
candidate_x <- rnorm(1, previous_x, sqrt(candidate_variance))
candidate_y <- rnorm(1, previous_y, sqrt(candidate_variance))
alpha <- min( 1,
target(candidate_x, candidate_y) / target(previous_x, previous_y) *
candidate(previous_x,previous_y,candidate_x,candidate_y,candidate_variance) /
candidate(candidate_x,candidate_y,previous_x,previous_y,candidate_variance)
)
u <- runif(1)
accept <- ifelse(u < alpha, "Yes", "No")
if (u < alpha) {
retained_x <- candidate_x; retained_y <- candidate_y
} else {
retained_x <- previous_x; retained_y <- previous_y
}
df <- df %>%
bind_rows(data.frame(draw, previous_x, previous_y, candidate_x, candidate_y,
alpha, u, accept, retained_x, retained_y))
previous_x <- retained_x
previous_y <- retained_y
if(i %% 10000 == 0){ print(i) } # To observe progress of the loop
}

# Set burn in
burn_in <- 1000
# Acceptance Rate
df %>%
slice(-c(1:(burn_in+1))) %>%
group_by(accept) %>%
summarize(n=n()) %>%
mutate(proportion = n / sum(n))

# Set burn in
burn_in <- 1000
# P(a < -1 | y)
df %>%
slice(-c(1:(burn_in+1))) %>%
summarize(sum = sum(retained_x < -1),
n=n()) %>%
mutate(proportion = sum / n)

# P(b > 2)
df %>%
slice(-c(1:(burn_in+1))) %>%
summarize(sum = sum(retained_y > 2), n=n()) %>%
mutate(proportion = sum / n)
# P(ab < 0)
df %>%
slice(-c(1:(burn_in+1))) %>%
summarize(sum = sum(retained_x * retained_y < 0), n=n()) %>%
mutate(proportion = sum / n)
# Set burn-in
burn_in <- 1000
# Contour plot
# https://www.r-graph-gallery.com/2d-density-plot-with-ggplot2.html
df %>%
slice(-c(1:(burn_in+1))) %>%
ggplot(aes(x=retained_x, y=retained_y) ) +

stat_density_2d(aes(fill = ..level..),
geom = "polygon", colour="white") +
ylab("b") +
xlab("a") +
labs(title = "Density Plot") +
theme_bw() +
theme(panel.grid.major = element_blank()) +
theme(panel.grid.minor = element_blank()) +
theme(legend.position = "none") +
theme(plot.title = element_text(hjust = 0.5))

```


